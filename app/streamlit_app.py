import sys
from pathlib import Path

import numpy as np
import pandas as pd
import streamlit as st

# -------------------------------------------------------------------
# Path setup so we can import from src/
# -------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent  # .../urop-stock-nn
SRC_PATH = ROOT / "src"
if str(SRC_PATH) not in sys.path:
    sys.path.insert(0, str(SRC_PATH))

import config as cfg  # type: ignore

EXPERIMENT_SYMBOLS = cfg.EXPERIMENT_SYMBOLS
DEFAULT_SYMBOL = cfg.DEFAULT_SYMBOL

OUTPUTS_DIR = ROOT / "data" / "outputs"

# -------------------------------------------------------------------
# Streamlit page config
# -------------------------------------------------------------------
st.set_page_config(
    page_title="Equity Model Lab (Offline)",
    layout="wide",
)


# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------
@st.cache_data
def load_offline_history(symbol: str) -> pd.DataFrame:
    """
    Load pre-downloaded OHLCV history from data/outputs/{symbol}_lstm_results.csv

    These CSVs were generated by scripts/generate_all_outputs.py and
    contain daily OHLCV data (no live yfinance, no torch).
    """
    path = OUTPUTS_DIR / f"{symbol}_lstm_results.csv"
    if not path.exists():
        raise FileNotFoundError(f"No offline data file found for {symbol}: {path}")

    # Index col 0 is the date index from df.to_csv
    df = pd.read_csv(path, index_col=0, parse_dates=True)
    df = df.sort_index()
    df.index.name = "Date"

    # Coerce numeric columns in case anything was stored as string
    numeric_cols = ["Open", "High", "Low", "Close", "Adj Close", "Volume"]
    for col in numeric_cols:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    return df


def slice_window(df: pd.DataFrame, window_label: str) -> pd.DataFrame:
    """Take the last N rows based on a simple trading-day approximation."""
    if window_label == "Max":
        return df

    days_map = {
        "1M": 21,
        "3M": 63,
        "6M": 126,
        "1Y": 252,
        "5Y": 252 * 5,
    }
    n = days_map.get(window_label, 252)
    return df.tail(n)


def build_baseline_forecasts(
    df: pd.DataFrame,
    price_col: str = "Close",
) -> pd.DataFrame:
    """
    Construct baseline "forecast" series using only historical prices.

    We treat the baselines as one-step-ahead predictors:
    - Naive lag1: predict today's price using yesterday's price.
    - MA 5d: predict today's price using the 5-day moving average *up to t-1*.
    - MA 20d: same with 20 days.
    """
    if price_col not in df.columns:
        raise ValueError(f"Column {price_col} not in DataFrame")

    price = pd.to_numeric(df[price_col], errors="coerce")

    # One-step-ahead predictions use information up to t-1
    naive = price.shift(1)

    ma5 = (
        price.rolling(window=5, min_periods=1)
        .mean()
        .shift(1)
    )

    ma20 = (
        price.rolling(window=20, min_periods=1)
        .mean()
        .shift(1)
    )

    out = pd.DataFrame(
        {
            "Actual": price,
            "Naive lag1": naive,
            "MA 5d": ma5,
            "MA 20d": ma20,
        },
        index=df.index,
    )

    return out


def compute_metrics(y_true, y_pred) -> tuple[float, float]:
    """
    Compute MAE and RMSE between two numeric series.
    Filters out NaNs so we don't crash on early windows.
    """
    y_true = pd.to_numeric(pd.Series(y_true), errors="coerce")
    y_pred = pd.to_numeric(pd.Series(y_pred), errors="coerce")

    mask = y_true.notna() & y_pred.notna()
    if mask.sum() == 0:
        return float("nan"), float("nan")

    y_true = y_true[mask].to_numpy(dtype=float)
    y_pred = y_pred[mask].to_numpy(dtype=float)

    mae = float(np.mean(np.abs(y_true - y_pred)))
    rmse = float(np.sqrt(np.mean((y_true - y_pred) ** 2)))
    return mae, rmse


# -------------------------------------------------------------------
# Main app
# -------------------------------------------------------------------
def main():
    st.title("Equity Model Lab (Offline)")
    st.caption(
        "Offline research console for stock price baselines using precomputed OHLCV data "
        "from data/outputs/*.csv (no live yfinance, no PyTorch)."
    )

    st.sidebar.header("Universe and settings")

    mode = st.sidebar.radio("Mode", ["Predefined universe", "Custom symbol"])

    if mode == "Predefined universe":
        symbol = st.sidebar.selectbox(
            "Choose asset",
            options=EXPERIMENT_SYMBOLS,
            index=EXPERIMENT_SYMBOLS.index(DEFAULT_SYMBOL),
        )
    else:
        symbol = st.sidebar.text_input(
            "Enter symbol (must have CSV in data/outputs/)",
            value="AAPL",
        ).strip()

    window_label = st.sidebar.selectbox(
        "Time window",
        options=["1M", "3M", "6M", "1Y", "5Y", "Max"],
        index=3,
    )

    price_field = st.sidebar.selectbox(
        "Price field",
        options=["Adj Close", "Close", "Open", "High", "Low"],
        index=1,  # Close by default
    )

    tabs = st.tabs(["Overview", "Baselines"])

    # ------------------ Load data safely ------------------
    try:
        with st.spinner(f"Loading offline history for {symbol}"):
            df_full = load_offline_history(symbol)
    except Exception as e:
        for tab in tabs:
            with tab:
                st.error(f"Could not load offline data for {symbol}: {e}")
        return

    if price_field not in df_full.columns:
        # Fallback to Close if chosen field missing
        if "Close" in df_full.columns:
            price_col = "Close"
        else:
            price_col = df_full.columns[0]
    else:
        price_col = price_field

    df_window = slice_window(df_full, window_label)

    # ------------------ Overview tab ------------------
    with tabs[0]:
        st.subheader(f"{symbol} price overview")

        st.line_chart(
            df_window[price_col].rename("Price"),
            use_container_width=True,
        )

        st.write("Recent daily OHLCV")
        cols_to_show = [
            c for c in ["Open", "High", "Low", "Close", "Adj Close", "Volume"]
            if c in df_window.columns
        ]
        if cols_to_show:
            st.dataframe(
                df_window[cols_to_show].tail(20),
                use_container_width=True,
            )
        else:
            st.info("No standard OHLCV columns available to display.")

    # ------------------ Baselines tab ------------------
    with tabs[1]:
        st.subheader(f"{symbol} baseline forecasts (offline)")

        try:
            baseline_df = build_baseline_forecasts(df_window, price_col=price_col)
        except Exception as e:
            st.error(f"Could not build baselines for {symbol}: {e}")
            return

        # Plot actual vs baselines
        st.line_chart(baseline_df, use_container_width=True)

        # Compute simple metrics for each baseline vs Actual
        rows = []
        actual = baseline_df["Actual"]
        for col in ["Naive lag1", "MA 5d", "MA 20d"]:
            if col in baseline_df.columns:
                mae, rmse = compute_metrics(actual, baseline_df[col])
                rows.append(
                    {
                        "Model": col,
                        "MAE": mae,
                        "RMSE": rmse,
                    }
                )

        if rows:
            metrics_df = pd.DataFrame(rows).set_index("Model")
            st.write("Error metrics (offline, one-step ahead)")
            st.dataframe(
                metrics_df.style.format({"MAE": "{:.4f}", "RMSE": "{:.4f}"}),
                use_container_width=True,
            )
        else:
            st.info("No baseline metrics available for this data.")


if __name__ == "__main__":
    main()
